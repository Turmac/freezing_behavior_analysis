import matplotlib.pyplot as plt
import numpy as np
import cv2
import pandas as pd
import altair as alt


def read_label():
    filename = ''  # label file (csv) generated by body part detection network
    data = list()
    with open(filename, 'r') as fin:
        idx = 0
        for line in fin:
            if idx > 2:
                line_data = line.strip().split(',')
                line_data = [float(item) for item in line_data]
                data.append(line_data)
            idx += 1


def get_distance(data):
    count = 0
    total = 0
    for idx in range(1, len(data)):
        for i in range(9):
            x0, y0, p0 = data[idx-1][i*3+1:i*3+4]
            x1, y1, p1 = data[idx][i*3+1:i*3+4]
            if p0 > 0.8 and p1 > 0.8:
                dis = np.linalg.norm([y1-y0, x1-x0])
                total += dis
                count += 1
    if count == 0:
        return 0
    return total/count

def cal_avg_pix_moved(data):
    res = list()
    for idx in range(30):
        res.append(3)
        
    for idx in range(30, len(data)):
        avg_pix_moved = get_distance(data[idx-30: idx])
        res.append(avg_pix_moved)
    return res

def get_distance_center(data):
    x_means = list()
    y_means = list()
    
    # calculate center of each body part
    for i in range(9):
        xs, ys = [], []
        for idx in range(len(data)):
            x, y, p = data[idx-1][i*3+1:i*3+4]
            if p > 0.8:
                xs.append(x)
                ys.append(y)
        if xs and ys:
            x_means.append(np.mean(xs))
            y_means.append(np.mean(ys))
        else:
            x_means.append(-1)
            y_means.append(-1)
    
    #print(x_means)
    #print(y_means)
    
    count, total = 0, 0
    for i in range(9):
        if x_means[i] < 0 or y_means[i] < 0:
            continue
        for idx in range(len(data)):
            x, y, p = data[idx][i*3+1:i*3+4]
            if p > 0.8:
                total += np.linalg.norm([x-x_means[i], y-y_means[i]])
                count += 1
    
    #print(total, count)
    
    if count == 0:
        return 0
    return total/count

def get_pixel_distance_with_center(data):
    res = list()
    for idx in range(30):
        res.append(100)
    
    for idx in range(30, len(data)):
        distance = get_distance_center(data[idx-30:idx])
        res.append(distance)
    return res

def add_block(frame, c):
    for i in range(10, 90):
        for j in range(10, 90):
            frame[i, j, :] = c
    return frame

def add_block_small(frame, c):
    for i in range(10, 30):
        for j in range(10, 30):
            frame[i, j, :] = c
    return frame


def analyze_freezing_behavior():
    data = read_label()
    avg_pix_moved = cal_avg_pix_moved(data)
    avg_pix_moved_to_center = get_pixel_distance_with_center(data)

    # get plot of the body part moving distance
    plotting = False
    if plotting:
        d1 = list(zip(hist_dis_center[1], hist_dis_center[0]))
        df = pd.DataFrame(d1, columns =['average pixel moved distance', 'Count()'])
        alt.Chart(df).mark_bar().encode(
            alt.X("average pixel moved distance", bin=True),
            y='Count()',
        )

        d2 = list(zip(hist_dis[1], hist_dis[0]))
        df = pd.DataFrame(d2, columns =['average pixel moved distance', 'Count()'])

        alt.Chart(df).mark_bar().encode(
            alt.X("average pixel moved distance", bin=True),
            y='Count()',
        )

        # create result video
        freeze_threshold = 0.6

        writing = False
        logs = list()

        # Create a VideoCapture object and read from input file
        # If the input is the camera, pass 0 instead of the video file name
        video_path = '' # replace with the labelled video path
        cap = cv2.VideoCapture(video_path)
        resolution = (720, 1280)
        #resolution = (300, 400)

        if writing:
            output_path = '' # replace with output video path
            out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc('m', 'p', '4', 'v'), 30, resolution)

        # Check if camera opened successfully
        if (cap.isOpened()== False): 
            print("Error opening video stream or file")

        # Read until video is completed
        idx = 0
        freeze_frame = 0
        while(cap.isOpened()):
            # Capture frame-by-frame
            ret, frame = cap.read()

            if idx >= len(avg_pix_moved):
                break
            
            dis = avg_pix_moved[idx]
            dis_center = avg_pix_moved_to_center[idx]
            #print(dis_center, end='\r')
            
            if dis < 0.5 and dis_center < 0.7:
                frame = add_block_small(frame, (0,0,255))
                freeze_frame += 1
            else:
                frame = add_block_small(frame, (0,255,0))

            idx += 1
            #if idx % 10000 == 0:
            #    print(idx, freeze_frame)
            #print(idx)
            
            seconds = idx//30
            #print('time: %d m: %d s, dis: %lf, dis_center: %lf' % (seconds//60, seconds%60, dis, dis_center), end='\r')
            logs.append('time: %d m: %d s, dis: %lf, dis_center: %lf' % (seconds//60, seconds%60, dis, dis_center))
            
            if ret == True:
                # Display the resulting frame
                #cv2.imshow('Frame',frame)
                
                if writing:
                    out.write(frame)

                # Press Q on keyboard to  exit
                #if cv2.waitKey(30) & 0xFF == ord('q'):
                #    break
            # Break the loop
            else: 
                break

        # When everything done, release the video capture object
        cap.release()
        if writing:
            out.release()

        # Closes all the frames
        cv2.destroyAllWindows()

        #print(idx, freeze_frame)


if __name__ == 'main':
    analyze_freezing_behavior()
